#!/usr/bin/env python
"""
Script to visualize positions of predicted Sup-tRNAs relative to switch in genetic code
"""
import pandas as pd
import matplotlib.pyplot as plt
import sys
import argparse
from matplotlib.lines import Line2D
import numpy as np
from Bio import SeqIO
import os


def parse_trnascan_results(path_results, target_genomes, output_dir):
    """
    Parse tRNAscan-SE 2 output files
    :param path_results: str, directory containing tRNAscan-SE 2 results
    :param target_genomes: list, target genomes
    :param output_dir: str, output directory. Will create a file named suppressor_trnas.tab in this directory
    summarizing the predicted Sup-tRNAs
    :return: pd.DataFrame, dataframe containing predicted Sup-tRNAs
    """
    results = []
    for f in target_genomes:
        # parse tRNAscan result file
        res = pd.read_csv(path_results + f + '.out', sep='\t', names=['Name', 'tRNA #', 'Begin', 'End', 'Type',
                                              'Codon', 'Intron_Begin', 'Intron_End', 'Score', 'Note'],
                          header=1, comment='-')
        results.append(res[res.Type == 'Sup'])
    # merge and filter
    results = pd.concat(results)
    results = results[results.Score >= 35]
    results = results[results.Note != 'pseudo'].reset_index(drop=True)
    results['Name'] = [x.strip() for x in results.Name.values]
    if results.shape[0] == 0:
        print('Did not find any suppressor tRNA')
        sys.exit()
    print("Found the following suppressor tRNAs")
    print(results.Codon.value_counts())
    results.to_csv(f"{output_dir}suppressor_trnas.tab", header=True, index=False, sep='\t')
    return results


def parse_mgcod_results(path_results, target_genomes, alternative_gcode):
    """
    Function to parse gene prediction and *.tab file generated by Mgcod
    :param path_results: str, path containing result files
    :param target_genomes: list, target genomes for which to parse results
    :param alternative_gcode: int, indicating alternative genetic code in target genomesd
    :return: pd.DataFrame, pd.DataFrame, Mgcod results, gene annotations
    """
    results = []
    predictions = []
    for f in target_genomes:
        # read mgcod results
        res = pd.read_csv(path_results + f + '.tab', sep='\t', header=0)
        contig = [res.iloc[0, 0]]
        genetic_code = [str([int(x) for x in res.iloc[1, 2:-1].values])]
        switch_point = [str([int(y) for x in res.iloc[0, 2:-1].values.tolist() for y in x[1:-1].split(', ')][1:-1])]        
        res = pd.DataFrame.from_dict({'contig': contig, 'genetic_code': genetic_code, 'switch_point': switch_point})
        results.append(res)
        # read gene annotation
        pred = pd.read_csv(path_results + f + '.gff', sep='\t', comment='#',
                           names=['sequence', 'source', 'feature', 'start',
                                   'end', 'logodd', 'strand', 'phase', 'attributes'])
        predictions.append(pred)
    # format
    results = pd.concat(results).reset_index(drop=True)
    results = results[results.genetic_code != 11]
    results = results[results.genetic_code != 4]
    results = results[results.genetic_code != 15]
    results = results[results.genetic_code != 101]
    results = results[['11' in x and alternative_gcode in x for x in results.genetic_code]].reset_index(drop=True)
    predictions = pd.concat(predictions).reset_index(drop=True)
    predictions = predictions.loc[np.isin(predictions.sequence, results.contig)].reset_index(drop=True)
    return results, predictions


def get_trna_positions(trnas, switch_points, predictions, alternative_genetic_code, target_genomes, path_genomes,
                       output_dir):
    """
    Function that roots the sequence such that the block encoding genes with code 11 is always on the positive strand
    and the genome starts with this block, and genes encoded with an alternative genetic code are always encoded
    negative strand. The position of Sup-tRNA in this rooted genome is then computed
    :param trnas: pd.DataFrame, Sup-tRNAs predicted by tRNAscan-SE
    :param switch_points: pd.DataFrame, Mgcod segementation results
    :param predictions: pd.DataFrame, gene annotation rendered by Mgcod
    :param alternative_genetic_code: int, alternative genetic code in target genomes
    :param target_genomes: list, target genomes which to analyze
    :param path_genomes: str, directory containing genomes
    :param output_dir: str, where to save output
    :return:
    """
    # infer suppressor tRNA anticodon
    if alternative_genetic_code == '4':
        trnas = trnas[trnas.Codon == 'TCA']
    elif alternative_genetic_code == '15':
        trnas = trnas[trnas.Codon == 'CTA']
    elif alternative_genetic_code == '101':
        trnas = trnas[trnas.Codon == 'TTA']

    contigs = [x.split('_')[-1] for x in target_genomes]
    positions_trnas = pd.DataFrame(columns=['contig', 'trna_start', 'trna_end', 'switch_point'])
    i = 0
    for con, tg in zip(contigs, target_genomes):
        pred = predictions[predictions.sequence == con]
        path_genome = f"{path_genomes}{tg}.fna"
        seq = list(SeqIO.parse(path_genome, 'fasta'))[0]
        contig_size = len(seq.seq)
        current_trnas = trnas[trnas.Name == con].reset_index(drop=True)
        if current_trnas.shape[0] == 0:
            continue
        # strand encoding most genes with alternative genetic code
        mode_strand = np.unique(pred[(pred.source == 'GeneMark.hmm2_{}'.format(alternative_genetic_code))].strand.values)\
                                    [np.argmax(np.unique(pred[(pred.source == 'GeneMark.hmm2_{}'.format(alternative_genetic_code))].strand.values,
                                                         return_counts=True)[1])]
        if mode_strand == '+':
            mode_strand = '-'
        elif mode_strand == '-':
            mode_strand = '+'
        column_order = 'genetic_code'
        column_sp = 'switch_point'
        # possible sequences of genetic codes
        scenario_1 = '[{}, 11, {}]'.format(alternative_genetic_code, alternative_genetic_code)
        scenario_2 = '[11, {}]'.format(alternative_genetic_code)
        scenario_3 = '[{}, 11]'.format(alternative_genetic_code)
        scenario_4 = '[11, {}, 11]'.format(alternative_genetic_code)
        current_trnas.loc[:, 'strand'] = np.argmin(current_trnas[['Begin', 'End']].values, axis=1)
        # root the sequence so that it starts with code 11 on positive strand
        if switch_points[switch_points.contig == con][column_order].values[0] == scenario_1:
            sps = [int(x) for x in switch_points[switch_points.contig == con][column_sp].values[0][1:-1].split(', ')]
            sp1 = np.mean([sps[0], sps[1]], dtype=np.int)
            sp2 = np.mean([sps[2], sps[3]], dtype=np.int)
            sp = sp2 - sp1
            # update tRNA position in rooted seq
            current_trnas['Begin'] -= sp1
            current_trnas['End'] -= sp1
            # construct rooted sequence
            if mode_strand == '+':
                rooted_seq = seq.seq[sp1: sp2] + seq.seq[sp2:] + seq.seq[:sp1]
            elif mode_strand == '-':
                rooted_seq = seq.seq[sp1:sp2].reverse_complement() + seq.seq[sp2:].reverse_complement() + \
                             seq.seq[:sp1].reverse_complement()
            # update tRNA position in rooted seq
            if mode_strand == '-':
                mode_strand = '+'
                current_trnas.strand = np.where(current_trnas.strand.values == 0, 1, 0)
                if sp >= current_trnas['Begin'].values[0]:
                    current_trnas['Begin'] = sp - current_trnas['Begin']
                    current_trnas['End'] = sp - current_trnas['End'] 
                else:
                    current_trnas['Begin'] = contig_size - (current_trnas['Begin'] - sp)
                    current_trnas['End'] = contig_size - (current_trnas['End'] - sp)
        elif switch_points[switch_points.contig == con][column_order].values[0] == scenario_2:
            sps = [int(x) for x in switch_points[switch_points.contig == con][column_sp].values[0][1:-1].split(', ')]
            if len(sps) == 2:
                sp = np.mean([sps[0], sps[1]], dtype=np.int)
                # construct rooted sequence
                if mode_strand == '+':
                    rooted_seq = seq.seq
                elif mode_strand == '-':
                    rooted_seq = seq.seq[:sp].reverse_complement() + seq.seq[sp:].reverse_complement()
            # update tRNA position in rooted seq
            if mode_strand == '-':
                mode_strand = '+'
                current_trnas.strand = np.where(current_trnas.strand.values == 0, 1, 0)

                if sp >= current_trnas['Begin'].values[0]:
                    current_trnas['Begin'] = sp - current_trnas['Begin']
                    current_trnas['End'] = sp - current_trnas['End']
                else:
                    current_trnas['Begin'] = contig_size - (current_trnas['Begin'] - sp)
                    current_trnas['End'] = contig_size - (current_trnas['End'] - sp)
        elif switch_points[switch_points.contig == con][column_order].values[0] == scenario_3:
            sps = [int(x) for x in switch_points[switch_points.contig == con][column_sp].values[0][1:-1].split(', ')]
            if len(sps) == 2:
                sp = np.mean([sps[0], sps[1]], dtype=np.int)
                sp = contig_size - sp
                # update tRNA position in rooted seq
                current_trnas['Begin'] += sp
                current_trnas['End'] += sp
                # construct rooted sequence
                if mode_strand == '+':
                    rooted_seq = seq.seq[sp:] + seq.seq[:sp]
                elif mode_strand == '-':
                    rooted_seq = seq.seq[sp:].reverse_complement() + seq.seq[:sp].reverse_complement()
            # update tRNA position in rooted seq
            if mode_strand == '-':
                mode_strand = '+'
                current_trnas.strand = np.where(current_trnas.strand.values == 0, 1, 0)

                if sp >= current_trnas['Begin'].values[0]:
                    current_trnas['Begin'] = sp - current_trnas['Begin']
                    current_trnas['End'] = sp - current_trnas['End']
                else:
                    current_trnas['Begin'] = contig_size - (current_trnas['Begin'] - sp)
                    current_trnas['End'] = contig_size - (current_trnas['End'] - sp)
        elif switch_points[switch_points.contig == con][column_order].values[0] == scenario_4:
            sps = [int(x) for x in switch_points[switch_points.contig == con][column_sp].values[0][1:-1].split(', ')]
            sp1 = np.mean([sps[0], sps[1]], dtype=np.int)
            sp2 = np.mean([sps[2], sps[3]], dtype=np.int)
            sp = sp1 + (contig_size - sp2)
            # update tRNA position in rooted seq
            current_trnas['Begin'] += (contig_size - sp2)
            current_trnas['End'] += (contig_size - sp2)
            # construct rooted sequence
            if mode_strand == '+':
                 rooted_seq = seq.seq[sp2:] + seq.seq[:sp1] + seq.seq[sp1:sp2]
            elif mode_strand == '-':
                 rooted_seq = seq.seq[sp2:].reverse_complement() + seq.seq[:sp1].reverse_complement() + \
                              seq.seq[sp1:sp2].reverse_complement()
            # update tRNA position in rooted seq
            if mode_strand == '-':
                mode_strand = '+'
                current_trnas.strand = np.where(current_trnas.strand.values == 0, 1, 0)

                if sp >= current_trnas['Begin'].values[0]:
                   current_trnas['Begin'] = sp - current_trnas['Begin']
                   current_trnas['End'] = sp - current_trnas['End']
                else:
                   current_trnas['Begin'] = contig_size - (current_trnas['Begin'] - sp)
                   current_trnas['End'] = contig_size - (current_trnas['End'] - sp)
        seq.seq = rooted_seq
        if len(switch_points[switch_points.contig == con][column_order].values[0].split(', ')) <= 3:
            assert len(rooted_seq) == contig_size, "Something went wrong during rooting, {}".format(path_genome)
            if not os.path.isdir(f'{output_dir}rooted/'):
                os.mkdir(f'{output_dir}rooted/')
            SeqIO.write(seq, f"{output_dir}rooted/{path_genome.split('/')[-1]}", 'fasta')
        # save positions in rooted sequence
        for n in range(current_trnas.shape[0]):
            positions_trnas.loc[i, 'contig'] = con
            positions_trnas.loc[i, 'trna_start'] = current_trnas.loc[n, 'Begin']
            positions_trnas.loc[i, 'trna_end'] = current_trnas.loc[n, 'End']
            positions_trnas.loc[i, 'switch_point'] = sp
            positions_trnas.loc[i, 'contig_size'] = contig_size
            positions_trnas.loc[i, 'mode_strand'] = mode_strand
            positions_trnas.loc[i, 'strand'] = current_trnas.loc[n, 'strand']
            i += 1
    # correct positions of tRNAs that got shifted over the linearization point
    positions_trnas.loc[positions_trnas.trna_start < 0, 'trna_start'] += \
        positions_trnas.loc[positions_trnas.trna_start < 0, 'contig_size']
    positions_trnas.loc[positions_trnas.trna_start > positions_trnas.contig_size, 'trna_start'] -= \
        positions_trnas.loc[positions_trnas.trna_start > positions_trnas.contig_size, 'contig_size']
    positions_trnas.loc[positions_trnas.trna_end < 0, 'trna_end'] += \
        positions_trnas.loc[positions_trnas.trna_end < 0, 'contig_size']
    positions_trnas.loc[positions_trnas.trna_end > positions_trnas.contig_size, 'trna_end'] -= \
        positions_trnas.loc[positions_trnas.trna_end > positions_trnas.contig_size, 'contig_size']
    trna_starts = np.min(positions_trnas[['trna_start', 'trna_end']].values, axis=1)
    trna_ends = np.max(positions_trnas[['trna_start', 'trna_end']].values, axis=1)

    positions_trnas.loc[:, 'trna_start'] = trna_starts
    positions_trnas.loc[:, 'trna_end'] = trna_ends
    return positions_trnas


def plot_distance_from_switch(positions_trnas, alternative_genetic_code, output_dir):
    """
    Plot positions of suppressor tRNA in rooted sequences with respect to genetic code switch
    :param positions_trnas: pd.DataFrame, positions of suppressor tRNAs in rooted sequence
    :param alternative_genetic_code: int, alternative genetic code in target genomes
    :param output_dir: str, directory where to save output figure named positions_of_sup_trna.pdf
    """
    fig, ax = plt.subplots()
    ax.set_xlabel('Position of Sup-CTA-tRNA')
    ax.annotate('Code 11 on positive protein-encoding strand', xy=(1.05,
                                                              positions_trnas.loc[:, 'contig'].unique().shape[0] + 5),
                fontsize=7)
    ax.annotate('Code {} on negative protein-encoding strand'.format(alternative_genetic_code),
                xy=(0.05, positions_trnas.loc[:, 'contig'].unique().shape[0] + 5), fontsize=7)
    handles = [Line2D([0], [0], color='blue', ls='-'),
               Line2D([0], [0], color='orange', ls='-'),
               Line2D([0], [0], color='black', ls='dashed')]
    labels = ['tRNA gene on positive PES',
              'tRNA gene on negative PES',
              'Code switch']
    ncol = 3
    ax.legend(handles, labels, bbox_to_anchor=(0.5, -.01), loc='upper center', ncol=ncol, fontsize=8, handlelength=1.5)
    pos_strand = 0
    neg_strand = 0
    current_positions =  positions_trnas.reset_index(drop=True)
    print(f"{current_positions.shape[0]} tRNAs in {current_positions.contig.unique().shape[0]} unique contigs")
    ax.set_xlim([0.0, 2.0])
    ax.set_ylim([-1, current_positions.contig.unique().shape[0] + 5])

    ax.spines['top'].set_visible(False)
    ax.spines['right'].set_visible(False)
    ax.spines['bottom'].set_visible(False)
    ax.spines['left'].set_visible(False)
    ax.yaxis.set_visible(False)
    ax.xaxis.set_visible(False)

    for i, contig in enumerate(current_positions.contig.unique()):
        current_trnas = current_positions[current_positions.contig == contig]
        distances = np.vstack([current_trnas.trna_start.values,
                               current_trnas.trna_start.values - current_trnas.switch_point.values,
                               current_trnas.trna_end.values - current_trnas.contig_size.values]).T
        for n in range(distances.shape[0]):
            if np.argmin(np.abs(distances[n])) == 0:
                segment_length = current_trnas.switch_point.values[0]
                start = 1 + current_trnas.trna_start.values[n] / segment_length

                end = start + 0.1
                if end > 2.0:
                    end = 2.0

            elif np.argmin(np.abs(distances[n])) == 1:
                if distances[n, 1] < 0:
                    segment_length = current_trnas.switch_point.values[0]
                    start = 1 + current_trnas.trna_start.values[n] / segment_length

                    end = start + 0.1
                    if end > 2.0:
                        end = 2.0

                elif distances[n, 1] >= 0:
                    segment_length = current_trnas.contig_size.values[0] - current_trnas.switch_point.values[0]
                    start = ((current_trnas.trna_start.values[n] - current_trnas.switch_point.values[0]) / segment_length)

                    end = start + 0.1
                    if end > 1.0:
                        end = 1.0

            elif np.argmin(np.abs(distances[n])) == 2:
                segment_length = current_trnas.contig_size.values[0] - current_trnas.switch_point.values[0]
                start = (current_trnas.trna_start.values[n] - current_trnas.switch_point.values[0]) / segment_length

                end = start + 0.1
                if end > 1.0:
                    end = 1.0
            if current_trnas.strand.values[n] == 0 and current_trnas.mode_strand.values[0] == '+':
                color = 'blue'
                pos_strand += 1
            elif current_trnas.strand.values[n] == 0 and current_trnas.mode_strand.values[0] == '-':
                color = 'orange'
                neg_strand += 1
            elif current_trnas.strand.values[n] == 1 and current_trnas.mode_strand.values[0] == '+':
                color = 'orange'
                neg_strand += 1
            elif current_trnas.strand.values[n] == 1 and current_trnas.mode_strand.values[0] == '-':
                color = 'blue'
                pos_strand += 1
            if current_trnas.mode_strand.values[0] == '+':
                ls = '-'
            else:
                ls = ':'
            if start < 0.5:
                print(contig)
            ax.hlines(i, start, end, color=color, linestyles=ls)
    print(f"{pos_strand} tRNAs on (+)-strand")
    print(f"{neg_strand} tRNAs on (-)-strand")
    ax.vlines(1, 0, current_positions.contig.unique().shape[0], linestyles='dashed', alpha=0.6, color='black')
    fig.savefig(f'{output_dir}positions_of_sup_trna.pdf', bbox_inches='tight', dpi=600)


def main(argv):
    parser = argparse.ArgumentParser(description="Visualizes positions of predicted Sup-tRNAs relative to switch "
                                                 "region in genetic code under consideration of strand and genetic "
                                                 "code information")
    parser.add_argument('--path_mgcod_results', help='Directory of Mgcod results', required=True)
    parser.add_argument('--path_trnascan_results', help='Directory of tRNAscan results', required=True)
    parser.add_argument('--path_to_genomes', help='Directory of genomes', required=True)
    parser.add_argument('--target_genomes', help='File names of target genomes, one entry per line and without '
                                                 'fasta extension', required=True)
    parser.add_argument('--alternative_gcode', help='Alternative genetic code', required=True)
    parser.add_argument('--output_dir', help='Output Directory', required=True)
    args = parser.parse_args()
    target_genomes = []
    with open(args.target_genomes, 'r') as tg:
        for line in tg:
            line = line.strip()
            target_genomes.append(line.split('/')[-1].split('.fna')[0])
    tg.close()
    sup_trnas = parse_trnascan_results(args.path_trnascan_results, target_genomes, args.output_dir)
    switch_points, predictions = parse_mgcod_results(args.path_mgcod_results, target_genomes, args.alternative_gcode)
    positions_trnas = get_trna_positions(sup_trnas, switch_points, predictions, args.alternative_gcode, target_genomes,
                                         args.path_to_genomes, args.output_dir)
    plot_distance_from_switch(positions_trnas, args.alternative_gcode, args.output_dir)


if __name__ == '__main__':
    main(sys.argv[1:])
